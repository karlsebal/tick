#!/bin/bash

OUTFILE="$HOME/.tick/protocol.csv"
OUTDIR="${OUTFILE%/*}"
PARSER="$HOME/bin/particl"

# check outdir existence
# create if none
[[ ! -d $OUTDIR ]] && {
	mkdir -vp "$OUTDIR" || exit -1
}

# check outfile existence
# create if none
[[ ! -f $OUTFILE ]] && {
	touch $OUTFILE || exit -1
}

shopt -s extglob

# give a short usage
short_help () {
	echo "usage: ${0##*/} -hadmyDY [command] [comment]"
}

# give a detailed help
help() {
	short_help

	cat <<-EOF

		========
		options:
		========

		-h	help
		
		-d	set day
		-m	set month
		-y	set year
		-D	set date
		-Y	set to yesterday

		Note: -D option is dominant over -dmy. With -Y mixed last given wins.

		-a	set amamedis


		=========
		commands:
		=========

		<HH[:MM]>         duration
		<HH:MM>-<HH:MM>   from-to	

		parse             parse protocol
		state
		report
		sync              sync protocol to backup location

		undo              undo last entry
		redo              redo last undo

		completion        install shell completion

EOF
}

# append entry to $OUTFILE
entry() {

	# feedback
	printf "entry for "
	
	[[ $identifier == a ]] && {
		printf "amamedis:\n"
	} || {
		printf "euratel:\n"
	}

	printf "for date $date enter\n"
	printf "$(bc <<< "scale=2; $durations/3600") hours "
	printf "($((durations/3600)):$((durations/60)) or "
	printf "$((durations/60)) minutes) \n"
	printf "${from:-from}-${to:-to not set}"
	printf "${unix_from:+(}${unix_from:-}${unix_from:+-}${unix_to:-}${unix_to:+)} \n"
	printf "with comment: $comment \n"

	# entry
	echo $identifier,$(date -d "$date" +%Y,%m,%d),$durations,$unix_from,$unix_to,\"$comment\" >> $OUTFILE
}

# command line parsing

# if an option or bunch of options
# they are parsed into an array
# if option demands an argument 
# it’s read from $1 and $skip_next is increased

# the stripped commandline
# we will append to this so
# the first entry will be 
# ${stripped[1]}
stripped=""

# number of arguments to be skipped
skip_next=0

# set identifier to Euratel
identifier=e

for arg in "$@"; do

	# skip arguments demanded by options
	# and already parsed
	[[ $skip_next -gt 0 ]] && {
		((skip_next--))
		continue
	}

	# options parsing
	# if we encount an option we will unset arg[0]
	# and move options to $arg[0+n]


	# do we have a bunch of options?
	[[ $arg =~ ^-[^-] ]] && {
		# parse letters into array…
		for i in $(seq 1 ${#arg}); do
			arg[$i]=${arg:$i:1}
		done
		# …and remove original
		unset arg[0]
	}

	# do we have a long option?
	[[ $arg =~ ^-- ]] && {
		# move the option to arg[1] and clean arg[0]
		arg[1]=$arg
		unset arg[0]
	}


	# now we have $arg clean which now contains
	# either a command or command parameter or null
	# $arg[@] needs cleanup to work properly which is
	# done in the loop handling it at last

	# this will parse the bunch-of-options as well
	# as single arguments where the loop is executed
	# only once. 
	# When an option occures demanding a second parameter
	# always $1 is used and skip_next is increased. 

	# for $arg[@] cleanup
	idx=1

	# only if $arg[0] is unset there are options to handle
	# short options are missing the leading dash since parsing to $arg
	# where long options kept their leading dashes
	[[ ! ${arg[0]} ]] && {
		for option in "${arg[@]}"; do
				case $option in

					--) echo -- stop reading arguments
						stripped=("${stripped[@]}" "$@")
						break 2
						;;

					h|\?|--help) help
						;;

					d|--day) 
						day=$1
						# be grateful with missing leading zero
						[[ ${#day} -eq 1 ]] && day=0$day
						((skip_next++))
						;;

					m|--month)
						month=$1
						# be grateful with missing leading zero
						[[ ${#month} -eq 1 ]] && month=0$month
						((skip_next++))
						;;

					y|--year)
						year=$1
						# be grateful with missing leading zero
						[[ ${#year} -eq 1 ]] && year=0$year
						((skip_next++))
						;;

					D|--date)
						date=$1
						((skip_next++))
						;;

					Y|--yesterday) 
						date=$(date -d 'yesterday' +%F)
						echo
						;;

					a|--amamedis) 
						identifier=a
						;;

					"") # ignore empty
						;;

					*) echo unrecognized option: \"-$option\"
						;;

				esac
		# cleanup!
		unset arg[$((idx++))]
		done
	} || {
		# not an option or bunch.
		# store command or command parameter
		stripped=("${stripped[@]}" "$arg")
	}
done

# now after option parsing $stripped should contain only
# command and argument

# assemble date
# if date is set, other options -dmy are ignored.
if [[ $date ]]; then
	# sanitize
	date=$(date -d "$date" +%F)
else
	date=$(date -d "${year:-$(date +%y)}${month:-$(date +%m)}${day:-$(date +%d)}" +%F)
fi

# exit on error while setting date
[[ $? -ne 0 ]] && {
	echo error setting date
	exit -1
}


# we are done parsing the options and setting the date.
case ${stripped[1]} in

	# catch empty
	"") 
		help
		;; 

	# duration given
	*([0-9])*(:)*([0-9]))
		duration=${stripped[1]}

		[[ $duration =~ : ]] && {
			[[ ${a:0:1} == : ]] && { 
				minutes=$duration
				hours=0
			} || {
				hours=${duration%%:*}
				minutes=${duration##*:}
			}
		} || {
			hours=$duration
			minutes=0
		}

		$hours hours and $minutes minutes
		durations=$((hours*3600+minutes*60))

		unset from
		unset to
		unset unix_from
		unset unix_to
		unset stripped[1]

		comment=${stripped[@]}

		entry
		;;

	# from-to given
	*([0-9])*(:)*([0-9])-*([0-9])*(:)*([0-9]))
		fromto=${stripped[1]}

		from=${fromto%%-*}
		[[ ! $from =~ : ]] && from="$from:00"

		to=${fromto##*-}
		[[ ! $to =~ : ]] && to="$to:00"

		unix_from=$(date -d "$from" +%s) || {
			echo error setting unix_from
			exit -1
		}

		unix_to=$(date -d "$to" +%s) || {
			echo error setting unix_to
			exit -1
		}

		durations=$((unix_to-unix_from))
		
		unset stripped[1]
		comment=${stripped[@]}

		entry
		;;

	parse)
		$PARSER $OUTFILE
		;;

	report) 
		echo not implemented yet
		exit 1
		;;

	sync)
		echo not implemented yet
		exit 1
		;;
	
	state)
		echo not implemented yet
		exit 1
		;;

	undo)
		echo not implemented yet
		exit 1
		;;
	
	redo)
		echo not implemented yet
		exit 1
		;;
	
	completion)
		echo not implemented yet
		exit 1
		;;

	
	*) 
		echo command not found: ${stripped[@]}
		exit -1
		;;
esac

# vim: ai sw=4 sts=4 ts=4 noexpandtab
