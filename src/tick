#!/bin/bash

OUTFILE="$HOME/.tick/protocol.csv"
OUTDIR="${OUTFILE%/*}"
PARSER="$HOME/bin/particl"

[[ ! -d $OUTDIR ]] && {
	mkdir -vp "$OUTDIR" || exit -1
}

[[ ! -f $OUTFILE ]] && {
	touch $OUTFILE || exit -1
}

shopt -s extglob

short_help () {
	echo "usage: ${0##*/} -hadmyDY [command] <time> <description>"
}

help() {
	short_help

	cat <<-EOF

		options:

		-h	help
		
		-d	set day
		-m	set month
		-y	set year
		-D	set date
		-Y	set to yesterday

		Note: -D option is dominant over -dmy. With -Y mixed last given wins.

		-a	set amamedis


		commands:

		<HH[:MM]>			duration
		<HH:MM>-<HH:MM>		from-to	
		parse
		state
		report
		sync

		undo
		redo

		completion

EOF
}

# if an option or bunch of options
# they are parsed into an array
# if option demands an argument 
# its read from $1 and $skip_next is increased
# shifts are done for option, bunch of options
# and parameter demanded by an option

# the stripped commandline
# we will append to this so
# the first entry will be 
# ${stripped[1]}
stripped=""

# number of arguments to be skipped
skip_next=0

for arg in "$@"; do

	# skip arguments demanded by options
	# and already shifted
	[[ $skip_next -gt 0 ]] && {
		((skip_next--))
		continue
	}

	# shift for every command, option, bunch
	shift

	# options parsing
	# if we encount an option we will unset arg[0]
	# and move options to $arg[0+n]

	# do we have a bunch of options?
	[[ $arg =~ ^-[^-] ]] && {
		# parse letters into array…
		for i in $(seq 1 ${#arg}); do
			arg[$i]=${arg:$i:1}
		done
		# …and remove original
		unset arg[0]
	}

	# do we have a long option?
	[[ $arg =~ ^-- ]] && {
		# move the option to arg[1] and clean arg[0]
		arg[1]=$arg
		unset arg[0]
	}

	# now we have $arg clean which now contains
	# either a command or command parameter or null
	# $arg[@] needs cleanup to work properly which is
	# done in the loop handling it at last

	# this will parse the bunch-of-options as well
	# as single arguments where the loop is executed
	# only once. 
	# When an option occures demanding a second parameter
	# always $1 is used, shifted and skip_next is increased. 

	# for $arg[@] cleanup
	idx=1

	# only if $arg[0] is unset there are options to handle
	[[ ! ${arg[0]} ]] && {
		for option in "${arg[@]}"; do
				case $option in

					--) echo -- stop reading arguments
						stripped=("${stripped[@]}" "$@")
						break 2
						;;

					h|\?|--help) help
						;;

					d|--day) 
						day=$1
						# be grateful with missing leading zero
						[[ ${#day} -eq 1 ]] && day=0$day
						shift
						((skip_next++))
						;;

					m|--month)
						month=$1
						# be grateful with missing leading zero
						[[ ${#month} -eq 1 ]] && month=0$month
						shift
						((skip_next++))
						;;

					y|--year)
						year=$1
						# be grateful with missing leading zero
						[[ ${#year} -eq 1 ]] && year=0$year
						shift
						((skip_next++))
						;;

					D|--date)
						date=$1
						shift
						((skip_next++))
						;;

					Y|--yesterday) 
						date=$(date -d 'yesterday' +%F)
						echo
						;;

					a|--amamedis) echo set amamedis
						amamedis=true
						;;

					"") # ignore empty
						;;

					*) echo unrecognized option: \"-$option\"
						;;

				esac
		# cleanup!
		unset arg[$((idx++))]
		done
	} || {
		# not an option or bunch.
		# store command or command parameter
		stripped=("${stripped[@]}" "$arg")
	}
done

# assemble date
# if date is set, other options -dmy are ignored.
if [[ $date ]]; then
	# sanitize
	date=$(date -d "$date" +%F)
else
	date=$(date -d "${year:-$(date +%y)}${month:-$(date +%m)}${day:-$(date +%d)}" +%F)
fi

[[ $? -ne 0 ]] && {
	echo error setting date
	exit -1
}

echo amamedis is ${amamedis:-not set}

# we are done parsing the options.
# parse command
case ${stripped[1]} in

	"") ;; # catch empty

	*([0-9])*(:)*([0-9]))
		duration=${stripped[1]}

		[[ $duration =~ : ]] && {
			[[ ${a:0:1} == : ]] && { 
				minutes=$duration
				hours=0
			} || {
				hours=${duration%%:*}
				minutes=${duration##*:}
			}
		} || {
			hours=$duration
			minutes=0
		}

		echo hours:$hours minutes:$minutes
		durations=$((hours*3600+minutes*60))

		unset from
		unset to
		unset unix_from
		unset unix_to
		unset stripped[1]

		comment=${stripped[@]}

		execute=entry
		;;

	*([0-9])*(:)*([0-9])-*([0-9])*(:)*([0-9]))
		fromto=${stripped[1]}

		from=${fromto%%-*}
		[[ ! $from =~ : ]] && from="$from:00"

		to=${fromto##*-}
		[[ ! $to =~ : ]] && to="$to:00"

		unix_from=$(date -d "$from" +%s) || {
			echo error setting unix_from
			exit -1
		}

		unix_to=$(date -d "$to" +%s) || {
			echo error setting unix_to
			exit -1
		}

		durations=$((unix_to-unix_from))
		
		unset stripped[1]
		comment=${stripped[@]}
		execute=entry
		;;

	parse)
		execute=parse
		;;

	report) echo report.
		execute=report
		;;
	
	*) echo command not found: ${stripped[@]}
esac


# command execution

case $execute in
	entry)
		echo $date $(bc <<< "scale=2; $durations/3600")h \($durations\) $from-$to \($unix_from-$unix_to\) $comment 
		echo e,$(date -d "$date" +%Y,%m,%d),$durations,$unix_from,$unix_to,\"$comment\" | tee -a $OUTFILE
		;;
	parse)
		$PARSER $OUTFILE
		;;
	*)
		echo nothing to do
		;;
esac

# vim: ai sw=4 sts=4 ts=4 noexpandtab
